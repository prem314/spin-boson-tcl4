# -*- coding: utf-8 -*-
"""Python Code to Load Objects from File

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ISJQVd1JJSKcsl7AUh0RNqwg_1gLa8XA
"""

import ast # Import the Abstract Syntax Trees module for safe literal evaluation
import os  # Import os module to handle file paths
import re  # Import regular expressions for more robust replacement

import numpy as np
from scipy.linalg import expm
import matplotlib.pyplot as plt
from qutip import basis, sigmax, sigmay, sigmaz
from qutip.solver.heom import DrudeLorentzBath
from qutip.solver.heom import DrudeLorentzPadeBath
from qutip.solver.heom import HEOMSolver

# --- Configuration ---
# Specify the filename created by the Mathematica script.
# Assumes the Python script is run from the same directory where Mathematica saved the file.
# If not, provide the full path to the file.
filename = "/home/premkr/Dropbox/work/projects/tcl4_dynamics/python_objects.txt" # Make sure this matches the Mathematica output file

# --- Main Loading Logic ---
loaded_objects = [] # Initialize an empty list to store the loaded objects

# Check if the file exists before trying to open it
if os.path.exists(filename):
    print(f"Reading objects from file: {filename}")
    try:
        # Open the file for reading
        # 'with open' ensures the file is automatically closed even if errors occur
        with open(filename, 'r', encoding='utf-8') as f:
            # Read the file line by line
            for i, line in enumerate(f):
                # Strip leading/trailing whitespace (like the newline character '\n')
                processed_line = line.strip()

                # Skip empty lines if any
                if not processed_line:
                    continue

                # --- Preprocessing for Python Compatibility ---
                # 1. Replace Mathematica's scientific notation "*^" with Python's "e"
                python_compatible_line = processed_line.replace('*^', 'e')

                # 2. Replace Mathematica's imaginary "*I" with Python's "j"
                #    Using regex to be slightly more robust, ensuring it's preceded by a number or bracket/comma
                #    and potentially followed by whitespace, comma, or bracket.
                #    This handles cases like `[0. + 0.*I, ...]` or just `5*I`.
                #    It specifically looks for a digit, '.', or ']' before '*I'
                #    to avoid accidental replacements if "I" appears elsewhere.
                python_compatible_line = re.sub(r'(?<=[0-9\.\]])\*I', 'j', python_compatible_line)

                # --- Attempt to Parse ---
                try:
                    # Safely evaluate the *modified* string representation of the object
                    # ast.literal_eval parses basic Python literals (strings, numbers, tuples,
                    # lists, dicts, booleans, None, complex) but not arbitrary code execution.
                    obj = ast.literal_eval(python_compatible_line)
                    loaded_objects.append(obj) # Add the parsed object to our list
                except (ValueError, SyntaxError) as parse_error:
                    # Handle cases where a line might not be valid Python literal syntax *even after conversion*
                    print(f"Warning: Could not parse line {i+1} after conversion.")
                    print(f"  Original:    '{processed_line}'")
                    print(f"  Converted:   '{python_compatible_line}'")
                    print(f"  Error:       {parse_error}")
                except Exception as e:
                    # Catch any other unexpected errors during parsing
                    print(f"Warning: An unexpected error occurred parsing line {i+1}: '{processed_line}'. Error: {e}")

        # --- Output ---
        print("\nSuccessfully loaded objects:")
        # Print the loaded objects for verification
        for index, item in enumerate(loaded_objects):
            # Use repr() for potentially complex objects to get a clearer representation
            print(f"  Index {index}: {repr(item)} (Type: {type(item).__name__})")

    except IOError as e:
        # Handle potential file reading errors (e.g., permissions)
        print(f"Error: Could not read file '{filename}'. IOError: {e}")
    except Exception as e:
        # Handle other potential errors during file processing
        print(f"An unexpected error occurred: {e}")

else:
    # Handle the case where the input file doesn't exist
    print(f"Error: The file '{filename}' was not found.")
    print("Please ensure the Mathematica script has run successfully and created the file,")
    print("or update the 'filename' variable in this Python script with the correct path.")

""" Mathematica parameters """
Gamma, Lambda, Omega, Beta, Theta, TCL2_gen, TCL4_gen = loaded_objects

a1 = np.sin(Theta)
a3 = np.cos(Theta)

lamval=1 # perturbatrive coupling strength

print("Gamma: ", Gamma)
print("Lambda: ", Lambda)
print("Omega: ", Omega)
print("Beta: ", Beta)
print("a1 and a3: ", a1, a3)
print("TCL2_gen: ", TCL2_gen)
print("TCL4_gen: ", TCL4_gen)

# TCL evolution(TCL2 and TCL4)

"""# HEOM Parameters"""
lam = np.pi * Lambda * Gamma /2

T = 1/Beta

# HEOM calculation

# Number of expansion terms to retain:
Nk = 32

max_depth = 2  # maximum hierarchy depth to retain


t0 = 0
tf = 250

time_sensity = 10

tTotal = tf * time_sensity

def time_val(t):
    return int(tTotal * t/(tf-t0))

t_extra = 30

t_large = time_val(t_extra)
print(t_large)



t_values_heom = np.linspace(t0, tf + t_extra, tTotal + t_large)

t_values = np.linspace(t0, tf , tTotal)

# The system Hamiltonian:

H_sys = (Omega / 2.0) * sigmaz()
# Initial state of the system:
rho0 = 0.5*(basis(2,0) * basis(2,0).dag() +  basis(2,1) * basis(2,1).dag()+ basis(2,1) * basis(2,0).dag()+ basis(2,0) * basis(2,1).dag())

# Bath properties
# Lambda = 0.8  # Frequncy cutoff
lam = (np.pi * Gamma * Lambda *lamval**2)/(2) # coupling conversion
T=1/Beta


# System-bath coupling operator:
Q = a3 * sigmaz() - a1 * sigmax()





# Matsubara expansion:
bath = DrudeLorentzBath(Q, lam, Lambda, T, Nk)

# Padé expansion:
#bath = DrudeLorentzPadeBath(Q, lam, Lambda, T, Nk)

# System-bath dynamics




options = {"nsteps": 15_000} # Is this another set of assumptions?

solver = HEOMSolver(H_sys, bath, max_depth=max_depth, options=options)

# Observables: Pauli matrices
e_ops = [sigmax(), sigmay(), sigmaz()]

# Run the solver

#tlist = np.linspace(0,100,1000)
result = solver.run(rho0, t_values_heom, e_ops = e_ops)

sigma_x_heom = result.expect[0][t_large]
sigma_y_heom = result.expect[1][t_large]
sigma_z_heom = result.expect[2][t_large]

"""# TCL2"""



L0gen = np.array([
    [0, 0, 0, 0],
    [0, 0, -Omega, 0],
    [0, Omega, 0, 0],
    [0, 0, 0, 0]
])

# Print the matrix
print("Schrodinger generator = ",L0gen)

L2 = L0gen + TCL2_gen
print("TCL2 generator = ",L2)

L4 = L2 + TCL4_gen
print("TCL4 generator = ",L4)






# Dynamics

vec = np.array([[1], [sigma_x_heom], [sigma_y_heom], [sigma_z_heom]]) # Initial state
#vec1= np.array([[1], [-1], [0], [0]])

# List to store the values for plotting
vecf_values = []
#vecf_values1 = []

# matrix exponential and vector multiplication for each time value
for t in t_values:
    ExpL = expm(L2 * t)
    vecf = np.dot(ExpL, vec)
    #vecf1 = np.dot(ExpL, vec1)

    # Appending to the list
    vecf_values.append([vecf[1, 0], vecf[2, 0], vecf[3, 0]])
    #vecf_values1.append([vecf1[1, 0], vecf1[2, 0], vecf1[3, 0]])

# Convert to numpy array for easier plotting
vec_tcl2 = np.array(vecf_values).real




"""# TCL4"""

# List to store the values for plotting
vecfinal_values = []
#vecfinal_values1 = []

# matrix exponential and vector multiplication for each time value
for t in t_values:
    ExpLfinal = expm(L4 * t)
    vecfinal = np.dot(ExpLfinal, vec)
    #vecfinal1 = np.dot(ExpLfinal, vec1)


   # Chop operation: Set values close to zero to zero
   # vecf = np.where(np.abs(vecf) < 1e-10, 0, vecf)

    # Appending to the list
    vecfinal_values.append([vecfinal[1, 0], vecfinal[2, 0], vecfinal[3, 0]])
    #vecfinal_values1.append([vecfinal1[1, 0], vecfinal1[2, 0], vecfinal1[3, 0]])

# Convert to numpy array for easier plotting
vec_tcl4 = np.array(vecfinal_values).real
#vecfinal_values1 = np.array(vecfinal_values1)

new_result_heom_0 = result.expect[0][t_large:]
new_result_heom_1 = result.expect[1][t_large:]
new_result_heom_2 = result.expect[2][t_large:]

"""# Plot"""









""" Fidelity Calculation """


# If the three components are plain Python lists, convert to NumPy first
x_vals = np.asarray(new_result_heom_0)   #  ⟨σx⟩(t)
y_vals = np.asarray(new_result_heom_1)   #  ⟨σy⟩(t)
z_vals = np.asarray(new_result_heom_2)   #  ⟨σz⟩(t)

# Stack them as columns → shape (T, 3)
new_result_heom = np.column_stack((x_vals, y_vals, z_vals))



import numpy as np
from scipy.linalg import sqrtm

# ---------------------------------------------
# Helpers
# ---------------------------------------------
# Pauli matrices in the computational basis
PAULI = np.array(
    [[[0, 1], [1, 0]],           # σx
     [[0, -1j], [1j, 0]],       # σy
     [[1, 0], [0, -1]]],        # σz
    dtype=complex
)

def bloch_to_rho(bloch):
    """
    Convert a Bloch‐vector array of shape (..., 3) to a density matrix array
    of shape (..., 2, 2).

    ρ = ½ (I + x σx + y σy + z σz)
    """
    bloch = np.asarray(bloch, dtype=float)
    # Identity term
    rho = 0.5 * np.eye(2, dtype=complex)
    # Add the Pauli contributions
    rho = rho + 0.5 * np.tensordot(bloch, PAULI, axes=([-1], [0]))
    return rho

def fidelity(ρ, σ):
    """
    Uhlmann fidelity F(ρ, σ) = (Tr√(√ρ σ √ρ))²  for a *single* pair.
    """
    # Matrix square root of ρ
    sqrt_rho = sqrtm(ρ)
    # Trace of the positive‐semidefinite matrix inside the square root
    inner = sqrtm(sqrt_rho @ σ @ sqrt_rho)
    return np.real_if_close(np.trace(inner))

# ---------------------------------------------
# Main front-end
# ---------------------------------------------
def fidelity_over_time(bloch_A, bloch_B):
    """
    Parameters
    ----------
    bloch_A : array_like, shape (T, 3)
        Time-ordered ⟨σx⟩, ⟨σy⟩, ⟨σz⟩ for state |A⟩.
    bloch_B : array_like, shape (T, 3)
        Time-ordered ⟨σx⟩, ⟨σy⟩, ⟨σz⟩ for state |B⟩.

    Returns
    -------
    F : ndarray, shape (T,)
        Fidelity at each time step.
    """
    bloch_A = np.asarray(bloch_A, dtype=float)
    bloch_B = np.asarray(bloch_B, dtype=float)

    if bloch_A.shape != bloch_B.shape or bloch_A.shape[-1] != 3:
        raise ValueError("Inputs must have identical shape (T, 3).")

    # Vectorised conversion to density matrices
    ρ = bloch_to_rho(bloch_A)    # shape (T, 2, 2)
    σ = bloch_to_rho(bloch_B)    # shape (T, 2, 2)

    # Compute fidelity for each time slice
    F = np.empty(ρ.shape[0])
    for t in range(ρ.shape[0]):
        F[t] = fidelity(ρ[t], σ[t])
    return F

# Suppose you already have the Pauli-expectation arrays:
# vec_tcl2 is shape (T, 3): columns are ⟨σx⟩, ⟨σy⟩, ⟨σz⟩
# new_result_heom is the same shape

F2_t = fidelity_over_time(vec_tcl2, new_result_heom)


F4_t = fidelity_over_time(vec_tcl4, new_result_heom)


#relError = (F4_t/F2_t)/


# ---------------- σ_x ----------------
plt.figure(figsize=(4,3))
plt.plot(t_values, (1-F2_t).real,
         label=r'TCL2',  color='blue')
plt.plot(t_values, (1-F4_t).real,
         label=r'TCL4', color='red')
plt.xlabel('Time');  
plt.ylabel(r'(1-Fidelity) wrt HEOM')
plt.yscale('log')
plt.legend(loc='lower right');
plt.tight_layout()
plt.savefig("fidelity_tcl2_tcl4.png")
plt.close()
